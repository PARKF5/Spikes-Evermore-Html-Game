<!DOCTYPE html>
<html>
<head>
<title>Spikes Evermore</title>
<link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="levelCounter">Level: 1</div>
<div id="cumCounter">Completed: 0</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const levelCounter = document.getElementById('levelCounter'); // Get the level counter element
const cumCounter = document.getElementById('cumCounter');

// Game state variables
let level = 1;

// Player Vars
let Upspeed = 4;
let Downspeed = 4;
let Rightspeed = 6;
let Leftspeed = 6;
let speedboostamount = 2; // The multiplier for the speed boost

// Player properties
const player = {
 x: 50,
 y: canvas.height - 50,
 width: 30,
 height: 30,
 color: 'blue',
 Upspeed: Upspeed,
 Downspeed: Downspeed,
 Rightspeed: Rightspeed,
 Leftspeed: Leftspeed,
 dx: 0,
 dy: 0
};

// Next level box properties
const nextLevelBox = {
 x: 700, // Position after the spikes
 y: canvas.height - 80,
 width: 50,
 height: 80,
 color: 'green'
};
//completeion times
let completedtimes = 0

// Spike properties (defined in a function to allow resetting for new levels)
let spikes = [];

// Walls array (separate for specific collision checks if needed, but not used globally for all levels currently)
let walls = [];

// Speed boost pads array (now a function scope variable)
let speedBoostPads = [];

function initializeSpikes() {
 walls = []; // Clear walls for new levels

 if (level === 1) {
 spikes = [
 // Vertical spikes (triangles for visual variety, but collision is still rectangular)
 { x: 200, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 90, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 350, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.4, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 500, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.6, direction: -1, shape: 'square', movementType: 'vertical' }
 ];
 } else if (level === 2) {
 // Level 2:
 spikes = [
 // Vertical spikes
 { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' }
 ];
 } else if (level === 3) {
 // Level 3:
 spikes = [
 // Vertical spikes
 { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' },
 // Horizontal spikes (squares)
 { x: 550, y: canvas.height - 50, width: 30, height: 30, initialX: 550, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 750, y: canvas.height - 250, width: 30, height: 30, initialX: 750, movementRange: 100, speed: 1.3, direction: -1, shape: 'square', movementType: 'horizontal' }
 ];
 } else if (level === 4) {
 // Level 4: Introduction to more complex horizontal movement and tighter spacing
 spikes = [
 { x: 100, y: canvas.height - 30, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 200, y: canvas.height - 150, width: 30, height: 30, initialX: 200, movementRange: 150, speed: 2.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 350, y: canvas.height - 30, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 150, speed: 1.8, direction: 1, shape: 'square', movementType: 'vertical' },
 { x: 500, y: canvas.height - 100, width: 30, height: 30, initialX: 500, movementRange: 200, speed: 2.2, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 650, y: canvas.height - 30, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.6, direction: -1, shape: 'square', movementType: 'vertical' }
 ];
 } else if (level === 5) {
 // Level 5: Mix of vertical and horizontal, moderate difficulty
 spikes = [
 { x: 100, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 120, speed: 1.5, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 250, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 150, speed: 1.8, direction: 1, shape: 'triangle', movementType: 'vertical' },
 { x: 400, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.3, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 550, y: canvas.height - 100, width: 30, height: 30, initialX: 550, movementRange: 150, speed: 2.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 700, y: canvas.height - 250, width: 30, height: 30, initialX: 700, movementRange: 100, speed: 1.8, direction: 1, shape: 'square', movementType: 'horizontal' }
 ];
 } else if (level === 6) {
 // Level 6: Tighter timing, faster movement
 spikes = [
 { x: 150, y: canvas.height - 30, width: 25, height: 30, initialY: canvas.height - 30, movementRange: 150, speed: 2.5, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 200, y: canvas.height - 30, width: 25, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 2.0, direction: 1, shape: 'square', movementType: 'vertical' },
 { x: 300, y: canvas.height - 30, width: 25, height: 30, initialY: canvas.height - 30, movementRange: 150, speed: 2.5, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 450, y: canvas.height - 200, width: 30, height: 30, initialX: 450, movementRange: 200, speed: 3.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 650, y: canvas.height - 400, width: 30, height: 30, initialX: 650, movementRange: 150, speed: 2.8, direction: 1, shape: 'square', movementType: 'horizontal' }
 ];
 } else if (level === 7) {
 // Level 7: A gauntlet with a mix of speeds
 spikes = [
 { x: 150, y: canvas.height - 30, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 200, speed: 2.0, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 200, y: canvas.height - 30, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.0, direction: 1, shape: 'triangle', movementType: 'vertical' },
 { x: 300, y: canvas.height - 200, width: 30, height: 30, initialX: 300, movementRange: 200, speed: 3.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 450, y: canvas.height - 300, width: 30, height: 30, initialX: 450, movementRange: 100, speed: 1.5, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 600, y: canvas.height - 400, width: 30, height: 30, initialY: canvas.height - 400, movementRange: 150, speed: 2.2, direction: -1, shape: 'square', movementType: 'vertical' },
 { x: 750, y: canvas.height - 500, width: 30, height: 30, initialX: 750, movementRange: 50, speed: 0.8, direction: -1, shape: 'square', movementType: 'horizontal' }
 ];
 } else if (level === 8) {
 // Level 8: Fast horizontal moving spikes only
 spikes = [
 { x: 800, y: canvas.height - 100, width: 30, height: 30, initialX: 800, movementRange: 700, speed: 4.0, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 750, y: canvas.height - 200, width: 30, height: 30, initialX: 750, movementRange: 700, speed: 6.5, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 800, y: canvas.height - 300, width: 30, height: 30, initialX: 800, movementRange: 700, speed: 4.0, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 750, y: canvas.height - 400, width: 30, height: 30, initialX: 750, movementRange: 700, speed: 6.5, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 800, y: canvas.height - 500, width: 30, height: 30, initialX: 800, movementRange: 700, speed: 4.0, direction: 1, shape: 'square', movementType: 'horizontal' }
 ];
 } else if (level === 9) {
 // Level 9: Dense vertical movement
 spikes = [
 { x: 120, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 3.0, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 150, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 2.0, direction: 1, shape: 'triangle', movementType: 'vertical' },
 { x: 250, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 3.0, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 350, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 3.0, direction: 1, shape: 'triangle', movementType: 'vertical' },
 { x: 450, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 2.0, direction: -1, shape: 'triangle', movementType: 'vertical' },
 { x: 550, y: canvas.height - 30, width: 40, height: 30, initialY: canvas.height - 30, movementRange: 550, speed: 3.0, direction: 1, shape: 'triangle', movementType: 'vertical' }
 ];
 } else if (level === 10) {
 // Level 10: Final Gauntlet of Speed
 spikes = [
 { x: 550, y: canvas.height - 30, width: 50, height: 50, initialX: 550, movementRange: 400, speed: 3.0, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 700, y: canvas.height - 200, width: 30, height: 30, initialX: 700, movementRange: 600, speed: 5.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 100, y: canvas.height - 300, width: 30, height: 30, initialX: 100, movementRange: 600, speed: 5.0, direction: 1, shape: 'square', movementType: 'horizontal' },
 { x: 700, y: canvas.height - 400, width: 30, height: 30, initialX: 700, movementRange: 600, speed: 5.0, direction: -1, shape: 'square', movementType: 'horizontal' },
 { x: 100, y: canvas.height - 500, width: 30, height: 30, initialX: 100, movementRange: 600, speed: 5.0, direction: 1, shape: 'square', movementType: 'horizontal' }
 ];
 } else {
 // Handle levels beyond the defined ones by showing a completion message and resetting to level 1
 completedtimes += 1
 alert("Congratulations!"+" - you have completed the game "+completedtimes+" Times!");
 level = 1;

 initializeSpikes(); // Reset to level 1
 }

 initializeSpeedBoostPads(); // Initialize pads whenever the level changes
 updateLevelCounter(); // Update the display when spikes are initialized/changed
 // Ensure the next level box is in its default position for these levels
 nextLevelBox.x = 700;
 nextLevelBox.y = canvas.height - 80;
}

// Function to initialize speed boost pads based on the current level
function initializeSpeedBoostPads() {
   const jumpBoostColor = '#9400d3'; // A rich violet hex number
 speedBoostPads = []; // Clear previous pads
 if (level === 1) {
 speedBoostPads.push({ x: 100, y: canvas.height - 200, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
 if (level === 2) {
 speedBoostPads.push({ x: 100, y: canvas.height - 200, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
 if (level === 4) {
 speedBoostPads.push({ x: 300, y: canvas.height - 300, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
  if (level === 5) {
 speedBoostPads.push({ x: 300, y: canvas.height - 300, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
  if (level === 6) {
 speedBoostPads.push({ x: 300, y: canvas.height - 200, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
  if (level === 7) {
 speedBoostPads.push({ x: 200, y: canvas.height - 100, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
  if (level === 8) {
 speedBoostPads.push({ x: 300, y: canvas.height - 400, width: 40, height: 40, color: jumpBoostColor, active: true });
 }
}

// Update the level counter display function
function updateLevelCounter() {
 levelCounter.textContent = 'Level: ' + level;
 cumCounter.textContent = 'Completed: ' + completedtimes;
}

// Function to apply the speed boost temporarily
function applySpeedBoost(pad) {
 if (pad.active) {
 // Store the original speeds before boosting
 player.originalUpspeed = player.Upspeed;
 player.originalDownspeed = player.Downspeed;
 player.originalRightspeed = player.Rightspeed;
 player.originalLeftspeed = player.Leftspeed;

 player.Upspeed *= speedboostamount;
 player.Downspeed *= speedboostamount;
 player.Rightspeed *= speedboostamount;
 player.Leftspeed *= speedboostamount;

 // Reset speed after a delay (5 seconds)
 setTimeout(resetPlayerSpeed, 5000);
 pad.active = false; // Make the specific pad one-time use
 }
}

// Function to reset player speed to original values
function resetPlayerSpeed() {
 // Only reset if they haven't been reset yet by a new level or game over
 if (player.originalUpspeed !== undefined) {
 player.Upspeed = player.originalUpspeed;
 player.Downspeed = player.originalDownspeed;
 player.Rightspeed = player.originalRightspeed;
 player.Leftspeed = player.originalLeftspeed;

 // Clear original speed properties
 delete player.originalUpspeed;
 delete player.originalDownspeed;
 delete player.originalRightspeed;
 delete player.originalLeftspeed;
 }
}

// Initialize spikes for level 1 on load
initializeSpikes();


// Draw functions
function drawPlayer() {
 ctx.fillStyle = player.color;
 ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawNextLevelBox() {
 ctx.fillStyle = nextLevelBox.color;
 ctx.fillRect(nextLevelBox.x, nextLevelBox.y, nextLevelBox.width, nextLevelBox.height);
}

function drawSpikes() {
 spikes.forEach(spike => {
 ctx.fillStyle = 'red';
 if (spike.shape === 'triangle') {
 // Draw a triangle shape for visual representation
 ctx.beginPath(); // Note: The collision uses the rectangular bounding box defined by x, y, width, height
 ctx.moveTo(spike.x, spike.y + spike.height); // Bottom left
 ctx.lineTo(spike.x + spike.width / 2, spike.y); // Top center
 ctx.lineTo(spike.x + spike.width, spike.y + spike.height); // Bottom right
 ctx.closePath();
 ctx.fill();
 } else if (spike.shape === 'square') {
 ctx.fillRect(spike.x, spike.y, spike.width, spike.height);
 }
 });
}

function drawSpeedBoostPads() {
 speedBoostPads.forEach(pad => {
 if (pad.active) {
 ctx.fillStyle = pad.color;
 ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
 }
 });
}

function drawWalls() {
 walls.forEach(wall => {
 ctx.fillStyle = wall.color;
 ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
 });
}

// --- Input Handling Changes ---
// Object to keep track of which keys are currently held down
const keys = {};

document.addEventListener('keydown', e => {
 // Use e.code instead of e.key for more consistent results across keyboard layouts
 keys[e.code] = true;
});

document.addEventListener('keyup', e => {
 keys[e.code] = false;
});


// Collision detection function
function isColliding(rect1, rect2) {
 // This function checks for AABB (Axis-Aligned Bounding Box) collision
 return (
 rect1.x < rect2.x + rect2.width &&
 rect1.x + rect1.width > rect2.x &&
 rect1.y < rect2.y + rect2.height &&
 rect1.y + rect1.height > rect2.y
 );
}


// Update functions
function updatePlayer() {
 // Store previous position before movement
 const prevX = player.x;
 const prevY = player.y;

 // Reset player velocity based on the currently held keys
 player.dx = 0;
 player.dy = 0;

 if (keys['ArrowRight'] || keys['KeyD']) player.dx = player.Rightspeed;
 if (keys['ArrowLeft'] || keys['KeyA']) player.dx = -player.Leftspeed;
 if (keys['ArrowUp'] || keys['KeyW']) player.dy = -player.Upspeed;
 if (keys['ArrowDown'] || keys['KeyS']) player.dy = player.Downspeed;

 // Apply movement to current position
 player.x += player.dx;
 player.y += player.dy;

 // Standard boundary checks since levels 1-4 use global boundaries
 if (player.x < 0) player.x = 0;
 if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
 if (player.y < 0) player.y = 0;
 if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;


 // Note: The walls array is empty for these levels, so this loop does nothing unless a future level uses walls.
 for (const wall of walls) {
 if (isColliding(player, wall)) {
 // Basic push back for safety if walls are added unexpectedly
 player.x = prevX;
 player.y = prevY;
 break;
 }
 }
}

function updateSpikes() {
 spikes.forEach(spike => {
 
 // Store previous position for collision resolution
 const prevSpikeX = spike.x;
 const prevSpikeY = spike.y;

 if (spike.movementType === 'vertical') {
 spike.y += spike.speed * spike.direction;
 } else if (spike.movementType === 'horizontal') {
 spike.x += spike.speed * spike.direction;
 }
 
 // Check collision with walls for spikes (this loop is largely inert now without specific wall levels)
 let collidedWithWall = false;
 for (const wall of walls) {
 if (isColliding(spike, wall)) {
 collidedWithWall = true;
 spike.x = prevSpikeX; 
 spike.y = prevSpikeY;
 spike.direction *= -1;
 break;
 }
 }
 
 // Use original boundary checks if no wall collision happened
 if (!collidedWithWall) {
 if (spike.movementType === 'vertical') {
 if (spike.direction === -1 && spike.y <= spike.initialY - spike.movementRange) {
 spike.direction = 1;
 } else if (spike.direction === 1 && spike.y >= spike.initialY) {
 spike.direction = -1;
 }
 } else if (spike.movementType === 'horizontal') {
 if (spike.direction === -1 && spike.x <= spike.initialX - spike.movementRange) {
 spike.direction = 1;
 } else if (spike.direction === 1 && spike.x >= spike.initialX) {
 spike.direction = -1;
 }
 }
 }
 });
}


function checkCollisions() {
 // Check collision with spikes
 for (const spike of spikes) {
 if (isColliding(player, spike)) {
 alert('Game Over! Level: ' + level);
 level = 1; // Reset to level 1
 initializeSpikes();
 resetPlayer();
 resetPlayerSpeed(); // Ensure speed is reset on game over
 return; // Exit the function to prevent multiple alerts or immediate level change
 }
 }

 // Check collision with next level box
 if (isColliding(player, nextLevelBox)) {
 level++;
 initializeSpikes();
 resetPlayer(); // Player position reset after level initialization
 resetPlayerSpeed(); // Ensure speed is reset when starting a new level
 }

 // Check collision with speed boost pads
 for (const pad of speedBoostPads) {
 if (pad.active && isColliding(player, pad)) {
 applySpeedBoost(pad);
 }
 }
}

function resetPlayer() {
 // Reset player to the starting area
 player.x = 50;
 player.y = canvas.height - 50;
 
 player.dx = 0;
 player.dy = 0;
 // Clear the keys object so that any held keys don't cause immediate movement after respawn.
 for (const key in keys) {
 if (keys.hasOwnProperty(key)) {
 keys[key] = false;
 }
 }
}

// Game loop function
function gameLoop() {
 ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

 drawWalls(); // Draw walls behind other elements
 drawNextLevelBox();
 drawSpeedBoostPads(); // Draw all active speed boost pads
 drawPlayer();
 drawSpikes();

 updatePlayer(); // This is where we now read the `keys` object
 updateSpikes();

 checkCollisions();

 requestAnimationFrame(gameLoop);
}

// Start the game loop
gameLoop();
</script>
</body>
</html>