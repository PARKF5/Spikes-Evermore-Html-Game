<!DOCTYPE html>
<html>
<head>
<title>Spikes Evermore</title>
<link rel="stylesheet" href="/style.css">
<style>
/* Optional basic style for the counter to make it visible */
#levelCounter {
    font-size: 24px;
    font-family: sans-serif;
    margin: 10px;
}
body {
    /* Prevents the user from accidentally selecting canvas text */
    user-select: none;
}
</style>
</head>
<body>
<div id="levelCounter">Level: 1</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const levelCounter = document.getElementById('levelCounter'); // Get the level counter element

// Game state variables
let level = 1;
// 106 is near the place to change jump boost color const
// Player Vars
let Upspeed = 4;
let Downspeed = 4;
let Rightspeed = 6;
let Leftspeed = 6;
let speedboostamount = 2; // The multiplier for the speed boost

// Player properties
const player = {
    x: 50,
    y: canvas.height - 50,
    width: 30,
    height: 30,
    color: 'blue',
    Upspeed: Upspeed,
    Downspeed: Downspeed,
    Rightspeed: Rightspeed,
    Leftspeed: Leftspeed,
    dx: 0,
    dy: 0
};

// Next level box properties
const nextLevelBox = {
    x: 700, // Position after the spikes
    y: canvas.height - 80,
    width: 50,
    height: 80,
    color: 'green'
};

// Spike properties (defined in a function to allow resetting for new levels)
let spikes = [];

// Speed boost pads array (now a function scope variable)
let speedBoostPads = [];

function initializeSpikes() {
    if (level === 1) {
        spikes = [
            // Vertical spikes (triangles for visual variety, but collision is still rectangular)
            { x: 200, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 90, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 350, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.4, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 500, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.6, direction: -1, shape: 'square', movementType: 'vertical' }
        ];
    } else if (level === 2) {
        // Level 2:
        spikes = [
            // Vertical spikes
            { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' }
        ];
    } else if (level === 3) {
        // Level 3:
        spikes = [
            // Vertical spikes
            { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' },
            // Horizontal spikes (squares)
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialX: 550, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'horizontal' },
            { x: 750, y: canvas.height - 250, width: 30, height: 30, initialX: 750, movementRange: 100, speed: 1.3, direction: -1, shape: 'square', movementType: 'horizontal' }
        ];
    } else if (level === 4) {
        // Level 4:
        spikes = [
            // Vertical spikes
            { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 500, speed: 5.0, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 3.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 4.1, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 200, width: 30, height: 30, initialY: canvas.height - 200, movementRange: 200, speed: 2.9, direction: -1, shape: 'square', movementType: 'vertical' },
            // Horizontal spikes (squares)
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialX: 550, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'horizontal' },
            { x: 240, y: canvas.height - 50, width: 30, height: 30, initialX: 440, movementRange: 300, speed: 4.5, direction: -1, shape: 'square', movementType: 'horizontal' },
            { x: 750, y: canvas.height - 250, width: 30, height: 30, initialX: 750, movementRange: 100, speed: 1.3, direction: -1, shape: 'square', movementType: 'horizontal' }
        ];
    }
    initializeSpeedBoostPads(); // Initialize pads whenever the level changes
    updateLevelCounter(); // Update the display when spikes are initialized/changed
}

// Function to initialize speed boost pads based on the current level
function initializeSpeedBoostPads() {
    speedBoostPads = []; // Clear previous pads
    // Define the rich violet color
    const jumpBoostColor = '#9400d3'; // A rich violet hex number

    if (level === 1) {
        speedBoostPads.push({ x: 100, y: canvas.height - 200, width: 40, height: 40, color: jumpBoostColor, active: true });
    }
    if (level === 2) {
        speedBoostPads.push({ x: 100, y: canvas.height - 200, width: 40, height: 40, color: jumpBoostColor, active: true });
    }
}

// Update the level counter display function
function updateLevelCounter() {
    levelCounter.textContent = 'Level: ' + level;
}

// Function to apply the speed boost temporarily
function applySpeedBoost(pad) {
    if (pad.active) {
        // Store the original speeds before boosting
        player.originalUpspeed = player.Upspeed;
        player.originalDownspeed = player.Downspeed;
        player.originalRightspeed = player.Rightspeed;
        player.originalLeftspeed = player.Leftspeed;

        player.Upspeed *= speedboostamount;
        player.Downspeed *= speedboostamount;
        player.Rightspeed *= speedboostamount;
        player.Leftspeed *= speedboostamount;

        // Reset speed after a delay (5 seconds)
        setTimeout(resetPlayerSpeed, 5000);
        pad.active = false; // Make the specific pad one-time use
    }
}

// Function to reset player speed to original values
function resetPlayerSpeed() {
    // Only reset if they haven't been reset yet by a new level or game over
    if (player.originalUpspeed !== undefined) {
        player.Upspeed = player.originalUpspeed;
        player.Downspeed = player.originalDownspeed;
        player.Rightspeed = player.originalRightspeed;
        player.Leftspeed = player.originalLeftspeed;

        // Clear original speed properties
        delete player.originalUpspeed;
        delete player.originalDownspeed;
        delete player.originalRightspeed;
        delete player.originalLeftspeed;
    }
}

// Initialize spikes for level 1 on load
initializeSpikes();

// Draw functions
function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawNextLevelBox() {
    ctx.fillStyle = nextLevelBox.color;
    ctx.fillRect(nextLevelBox.x, nextLevelBox.y, nextLevelBox.width, nextLevelBox.height);
}

function drawSpikes() {
    spikes.forEach(spike => {
        ctx.fillStyle = 'red';
        if (spike.shape === 'triangle') {
            // Draw a triangle shape for visual representation
            ctx.beginPath(); // Note: The collision uses the rectangular bounding box defined by x, y, width, height
            ctx.moveTo(spike.x, spike.y + spike.height); // Bottom left
            ctx.lineTo(spike.x + spike.width / 2, spike.y); // Top center
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height); // Bottom right
            ctx.closePath();
            ctx.fill();
        } else if (spike.shape === 'square') {
            ctx.fillRect(spike.x, spike.y, spike.width, spike.height);
        }
    });
}

function drawSpeedBoostPads() {
    speedBoostPads.forEach(pad => {
        if (pad.active) {
            ctx.fillStyle = pad.color;
            ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
        }
    });
}

// --- Input Handling Changes ---
// Object to keep track of which keys are currently held down
const keys = {};
document.addEventListener('keydown', e => {
    // Use e.code instead of e.key for more consistent results across keyboard layouts
    keys[e.code] = true;
});

document.addEventListener('keyup', e => {
    keys[e.code] = false;
});

// Update functions
function updatePlayer() {
    // Reset player velocity based on the currently held keys
    player.dx = 0;
    player.dy = 0;

    if (keys['ArrowRight'] || keys['KeyD']) player.dx = player.Rightspeed;
    if (keys['ArrowLeft'] || keys['KeyA']) player.dx = -player.Leftspeed;
    if (keys['ArrowUp'] || keys['KeyW']) player.dy = -player.Upspeed;
    if (keys['ArrowDown'] || keys['KeyS']) player.dy = player.Downspeed;

    // Apply movement based on current dx/dy values calculated above
    player.x += player.dx;
    player.y += player.dy;

    // Boundary checks (optional for simple game)
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    if (player.y < 0) player.y = 0;
    if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
}

function updateSpikes() {
    spikes.forEach(spike => {
        if (spike.movementType === 'vertical') {
            spike.y += spike.speed * spike.direction;
            if (spike.direction === -1 && spike.y <= spike.initialY - spike.movementRange) {
                spike.direction = 1;
            } else if (spike.direction === 1 && spike.y >= spike.initialY) {
                spike.direction = -1;
            }
        } else if (spike.movementType === 'horizontal') {
            spike.x += spike.speed * spike.direction;
            if (spike.direction === -1 && spike.x <= spike.initialX - spike.movementRange) {
                spike.direction = 1;
            } else if (spike.direction === 1 && spike.x >= spike.initialX) {
                spike.direction = -1;
            }
        }
    });
}

// Collision detection function
function isColliding(rect1, rect2) {
    // This function checks for AABB (Axis-Aligned Bounding Box) collision
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function checkCollisions() {
    // Check collision with spikes
    for (const spike of spikes) {
        // The existing isColliding function works perfectly fine for the rectangular bounds of the spike objects
        if (isColliding(player, spike)) {
            alert('Game Over! Level: ' + level);
            level = 1; // Reset to level 1
            initializeSpikes();
            resetPlayer();
            resetPlayerSpeed(); // Ensure speed is reset on game over
            return; // Exit the function to prevent multiple alerts or immediate level change
        }
    }

    // Check collision with next level box
    if (isColliding(player, nextLevelBox)) {
        level++;
        initializeSpikes();
        resetPlayer(); // Player position reset after level initialization
        resetPlayerSpeed(); // Ensure speed is reset when starting a new level
    }

    // Check collision with speed boost pads
    for (const pad of speedBoostPads) {
        if (pad.active && isColliding(player, pad)) {
            applySpeedBoost(pad);
        }
    }
}

function resetPlayer() {
    player.x = 50;
    player.y = canvas.height - 50;
    player.dx = 0;
    player.dy = 0;
    // FIX: Clear the keys object so that any held keys don't cause immediate movement after respawn.
    for (const key in keys) {
        if (keys.hasOwnProperty(key)) {
            keys[key] = false;
        }
    }
}

// Game loop function
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

    drawNextLevelBox();
    drawSpeedBoostPads(); // Draw all active speed boost pads
    drawPlayer();
    drawSpikes();

    updatePlayer(); // This is where we now read the `keys` object
    updateSpikes();

    checkCollisions();

    requestAnimationFrame(gameLoop);
}

// Start the game loop
gameLoop();
</script>
</body>
</html>
