<!DOCTYPE html>
<html>

<head>

<title>Spikes Evermore</title>

<link rel="stylesheet" href="/style.css">

</head>

<body>

<div id="levelCounter">Level: 1</div> <!-- Added level counter div -->

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const levelCounter = document.getElementById('levelCounter'); // Get the level counter element

// Game state variables
let level = 1;

// Player Vars
let Upspeed = 4;
let Downspeed = 4;
let Rightspeed = 6;
let Leftspeed = 6;
let speedboostamount = 2; // The multiplier for the speed boost

// Player properties
const player = {
    x: 50,
    y: canvas.height - 50,
    width: 30,
    height: 30,
    color: 'blue',
    Upspeed:Upspeed,
    Downspeed:Downspeed,
    Rightspeed:Rightspeed,
    Leftspeed:Leftspeed,
    dx: 0,
    dy: 0
};

// Next level box properties
const nextLevelBox = {
    x: 700, // Position after the spikes
    y: canvas.height - 80,
    width: 50,
    height: 80,
    color: 'green'
};

// Spike properties (defined in a function to allow resetting for new levels)
let spikes = [];
// Speed boost pads array (now a function scope variable)
let speedBoostPads = [];


function initializeSpikes() {
    if (level === 1) {
        spikes = [
            // Vertical spikes (triangles)
            { x: 200, y: canvas.height - 0, width: 20, height: 30, initialY: canvas.height - 0, movementRange: 90, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 350, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.4, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 500, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.6, direction: -1, shape: 'square', movementType: 'vertical' }
        ];
    } else if (level === 2) {
        // Level 2:
        spikes = [
            // Vertical spikes
            { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' }
        ];
    } else if (level === 3) {
        // Level 3:
        spikes = [
            // Vertical spikes
            { x: 150, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 50, speed: 1.0, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 280, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 70, speed: 1.2, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 410, y: canvas.height - 30, width: 20, height: 30, initialY: canvas.height - 30, movementRange: 60, speed: 1.1, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'vertical' },
            { x: 650, y: canvas.height - 100, width: 30, height: 30, initialY: canvas.height - 30, movementRange: 80, speed: 1.3, direction: -1, shape: 'square', movementType: 'vertical' },
            // Horizontal spikes (squares)
            { x: 550, y: canvas.height - 50, width: 30, height: 30, initialX: 550, movementRange: 100, speed: 1.5, direction: -1, shape: 'square', movementType: 'horizontal' },
            { x: 750, y: canvas.height - 250, width: 30, height: 30, initialX: 750, movementRange: 100, speed: 1.3, direction: -1, shape: 'square', movementType: 'horizontal' }
        ];
    }
    initializeSpeedBoostPads(); // Initialize pads whenever the level changes
    updateLevelCounter(); // Update the display when spikes are initialized/changed
}

// Function to initialize speed boost pads based on the current level
function initializeSpeedBoostPads() {
    speedBoostPads = []; // Clear previous pads
    if (level === 1) {
        speedBoostPads.push(
          { x: 100, y: canvas.height - 200, width: 40, height: 40, color: 'violet', active: true}
          );
    }

    if (level === 2) {
        speedBoostPads.push(
          { x: 100, y: canvas.height - 200, width: 40, height: 40, color: 'violet', active: true}
          );
    }

}

// Update the level counter display function
function updateLevelCounter() {
    levelCounter.textContent = 'Level: ' + level;
}

// Function to apply the speed boost temporarily
function applySpeedBoost(pad) {
    if (pad.active) {
        // Store the original speeds before boosting
        player.originalUpspeed = player.Upspeed;
        player.originalDownspeed = player.Downspeed;
        player.originalRightspeed = player.Rightspeed;
        player.originalLeftspeed = player.Leftspeed;

        player.Upspeed *= speedboostamount;
        player.Downspeed *= speedboostamount;
        player.Rightspeed *= speedboostamount;
        player.Leftspeed *= speedboostamount;

        // Reset speed after a delay (5 seconds)
        setTimeout(resetPlayerSpeed, 5000);
        pad.active = false; // Make the specific pad one-time use
    }
}

// Function to reset player speed to original values
function resetPlayerSpeed() {
    // Only reset if they haven't been reset yet by a new level or game over
    if (player.originalUpspeed !== undefined) {
        player.Upspeed = player.originalUpspeed;
        player.Downspeed = player.originalDownspeed;
        player.Rightspeed = player.originalRightspeed;
        player.Leftspeed = player.originalLeftspeed;
        // Clear original speed properties
        delete player.originalUpspeed;
        delete player.originalDownspeed;
        delete player.originalRightspeed;
        delete player.originalLeftspeed;
    }
}

// Initialize spikes for level 1 on load
initializeSpikes();

// Draw functions
function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawNextLevelBox() {
    ctx.fillStyle = nextLevelBox.color;
    ctx.fillRect(nextLevelBox.x, nextLevelBox.y, nextLevelBox.width, nextLevelBox.height);
}

function drawSpikes() {
    spikes.forEach(spike => {
        ctx.fillStyle = 'red';
        if (spike.shape === 'triangle') {
            ctx.beginPath();
            ctx.moveTo(spike.x, spike.y);
            ctx.lineTo(spike.x + spike.width / 2, spike.y - spike.height);
            ctx.lineTo(spike.x + spike.width, spike.y);
            ctx.closePath();
            ctx.fill();
        } else if (spike.shape === 'square') {
            ctx.fillRect(spike.x, spike.y, spike.width, spike.height);
        }
    });
}

function drawSpeedBoostPads() {
    speedBoostPads.forEach(pad => {
        if (pad.active) {
            ctx.fillStyle = pad.color;
            ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
        }
    });
}


// Update functions
function updatePlayer() {
    player.x += player.dx;
    player.y += player.dy;

    // Boundary checks (optional for simple game)
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    if (player.y < 0) player.y = 0;
    if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
}

function updateSpikes() {
    spikes.forEach(spike => {
        if (spike.movementType === 'vertical') {
            spike.y += spike.speed * spike.direction;
            if (spike.direction === -1 && spike.y <= spike.initialY - spike.movementRange) {
                spike.direction = 1;
            } else if (spike.direction === 1 && spike.y >= spike.initialY) {
                spike.direction = -1;
            }
        } else if (spike.movementType === 'horizontal') {
            spike.x += spike.speed * spike.direction;
            if (spike.direction === -1 && spike.x <= spike.initialX - spike.movementRange) {
                spike.direction = 1;
            } else if (spike.direction === 1 && spike.x >= spike.initialX) {
                spike.direction = -1;
            }
        }
    });
}

// Collision detection
function isColliding(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function checkCollisions() {
    // Check collision with spikes
    for (const spike of spikes) {
        if (isColliding(player, spike)) {
            alert('Game Over! Level: ' + level);
            level = 1; // Reset to level 1
            initializeSpikes();
            resetPlayer();
            resetPlayerSpeed(); // Ensure speed is reset on game over
            return;
        }
    }

    // Check collision with next level box
    if (isColliding(player, nextLevelBox)) {
        level++;
        initializeSpikes();
        resetPlayer();
        resetPlayerSpeed(); // Ensure speed is reset when starting a new level
    }

    // Check collision with speed boost pads
    for (const pad of speedBoostPads) {
        if (pad.active && isColliding(player, pad)) {
            applySpeedBoost(pad);
        }
    }
}

function resetPlayer() {
    player.x = 50;
    player.y = canvas.height - 50;
    player.dx = 0;
    player.dy = 0;
}

// Event listeners for player movement (keyboard arrows/WASD)
document.addEventListener('keydown', e => {
    if (e.key === 'ArrowRight' || e.key === 'd') player.dx = player.Rightspeed;
    if (e.key === 'ArrowLeft' || e.key === 'a') player.dx = -player.Leftspeed;
    if (e.key === 'ArrowUp' || e.key === 'w') player.dy = -player.Upspeed;
    if (e.key === 'ArrowDown' || e.key === 's') player.dy = player.Downspeed;
});

document.addEventListener('keyup', e => {
    if (e.key === 'ArrowRight' || e.key === 'd') player.dx = 0;
    if (e.key === 'ArrowLeft' || e.key === 'a') player.dx = 0;
    if (e.key === 'ArrowUp' || e.key === 'w') player.dy = 0;
    if (e.key === 'ArrowDown' || e.key === 's') player.dy = 0;
});

// Game loop function
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
    drawNextLevelBox();
    drawSpeedBoostPads(); // Draw all active speed boost pads
    drawPlayer();
    drawSpikes();
    updatePlayer();
    updateSpikes();
    checkCollisions();
    requestAnimationFrame(gameLoop);
}

// Start the game loop
gameLoop();
</script>
</body>
</html>
